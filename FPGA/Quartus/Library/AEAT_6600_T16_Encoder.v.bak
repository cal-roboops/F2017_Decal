// Module for reading 
// Input clk range: Max 1MHz, Min 50KHz
// Max sample rate depends on clk and bit resolution

module AEAT_6600_T16_Encoder #(
  parameter SSI_SAMPLE_RATE = 10, // Default 10 samp/s
  parameter SSI_RES = 10 // Default 10 bits
)(
  input clk,
  input SSI_CLK,

  // Chip inputs
  input data_in,
  input magHIGH,
  input magLOW,

  // Ready/Valid Interface
  input get_position,
  input data_out_rdy,
  output data_out_val,
  
  // Read register outputs
  output NCS, // CHIP Select
  output [SSI_RES-1:0] data_out
);
  // Local params
  localparam NUM_START_STATES = 2;
  localparam NUM_END_STATES = 1;
  localparam BIT_SELECT = SSI_RES + NUM_START_STATES;
  localparam NUM_STATES = SSI_RES + NUM_START_STATES + NUM_END_STATES - 1;
  localparam NUM_STATES_WIDTH = `log2(NUM_STATES);

  // Registers for Encoder
  reg start_read = 0, NCS_reg = 1'b1;
  reg data_out_val_reg = 1'b0, data_out_val_prev_reg =1'b0;
  reg [SSI_RES-1:0] data_out_reg = 0;
  reg [NUM_STATES_WIDTH-1:0] curr_state = 0;

  // Assign wires
  assign NCS = NCS_reg;
  assign data_out = data_out_reg;
  assign data_out_val = data_out_val_reg;

  // Sample Start Generator
  always@(posedge clk) begin
    // Restart reading on next SSI clock edge
    start_read <= (get_position || (start_read && !SSI_CLK));
    
    // Emit valid for 1 cycle if in end state, data_out_rdy is high, and haven't already
    if (curr_state == NUM_STATES) begin
      data_out_val_prev_reg <= (data_out_ready) ? 1'b1 : data_out_val_prev_reg;
      if (!data_out_val_prev_reg && data_out_ready) data_out_val_reg <= 1'b1;
      else data_out_val_reg <= 1'b0;
    end
    else begin
      data_out_val_reg <= 1'b0;
      data_out_val_prev_reg <= 1'b0;
    end
  end

  // Step through the states (bits)
  always @(posedge SSI_CLK) begin
    if (start_read) curr_state <= 0;
    else if (curr_state < NUM_STATES) curr_state <=  curr_state + 1;
    else curr_state <= curr_state;
  end

  // Read value from device
  always @(curr_state) begin
    case (curr_state)
      0 : NCS = 1;
      1 : NCS = 0;
      NUM_STATES : NCS = 1;
      default : data_out_reg[BIT_SELECT - curr_state] = data_in;
    endcase
  end