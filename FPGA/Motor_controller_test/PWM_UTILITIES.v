

//=======================================================
//  This code is generated by Cole
//=======================================================

module PWM_Gen #(
	parameter DUTY_MAX = 255,
	parameter DUTY_MAX_BITS = 8,
	parameter PWM_PERIOD = 1_000_000, //PWM_PERIOD * DUTY_MAX = DUTY_PERIOD
	parameter CLK_COUNTER_SIZE = 30
)
(
	input clk,
	input [DUTY_MAX_BITS-1:0] DUTY_NUM,
	output PWM 
);
	reg PWM_reg = 0;
	reg [DUTY_MAX_BITS-1:0] DUTY_count = 0;
	reg [CLK_COUNTER_SIZE-1:0] clk_counter = 0;

	assign PWM = PWM_reg;

	always @(posedge clk) begin
		clk_counter <= (clk_counter < PWM_PERIOD) ? clk_counter + 1 : 0;
		if(clk_counter == PWM_PERIOD) begin
			PWM_reg <= (DUTY_count < DUTY_NUM) ? 1 : 0;
			DUTY_count <= (DUTY_count < DUTY_MAX-1) ? DUTY_count + 1 : 0;
		end
	end
endmodule

module PWM_Counter #(
	parameter DUTY_MAX = 255,
	parameter DUTY_MAX_BITS = 8, //log2(duty_max)
	parameter PWM_PERIOD = 1_000_000,
	parameter CLK_COUNTER_SIZE = 30
)
(
	input clk,
	input pwm,
	output [DUTY_MAX_BITS-1:0] pwm_value
);
	
	reg [DUTY_MAX_BITS-1:0] counter = 0;
	reg [DUTY_MAX_BITS-1:0] value_reg = 0;
	reg [DUTY_MAX_BITS-1:0] DUTY_count = 0;
	reg [CLK_COUNTER_SIZE-1:0] clk_counter = 0;

	assign pwm_value = value_reg;

	always @(posedge clk) begin
		clk_counter <= (clk_counter < PWM_PERIOD) ? clk_counter + 1: 0;
		if(clk_counter == PWM_PERIOD) begin
			if(DUTY_count < DUTY_MAX-1) begin
				DUTY_count <= DUTY_count + 1;
				if(pwm) counter <= counter + 1;
			end
			else begin
				value_reg <= counter;
				counter <= 0;
				DUTY_count <= 0;
			end
		end
	end
	
endmodule

module pulse_counter #(
	//12 kHz
	parameter PULSE_MAX = 255,
	parameter PULSE_MAX_BITS = 8, //log2(PULSE_MAX)
	parameter TIMESTEP = 10, //in cycles
	parameter CLK_COUNTER_SIZE = 30 //log2(CYCLES_PER_SAMPLE)
)
(
	input clk,
	input pulse_sig,
	output [PULSE_MAX_BITS-1:0] pulse_num
);

	reg [PULSE_MAX_BITS-1:0] counter = 0;
	reg [PULSE_MAX_BITS-1:0] pulse_num_reg = 0;
	reg [CLK_COUNTER_SIZE-1:0] clk_counter = 0;

	assign pulse_num = pulse_num_reg;

	always @(posedge pulse_sig) begin
		pulse_num_reg <= pulse_num_reg + 1;
	end

	always @(posedge clk) begin
		clk_counter <= (clk_counter < TIMESTEP) ? clk_counter + 1: 0;
		pulse_num_reg <= (clk_counter == TIMESTEP) ? 0: pulse_num_reg;
	end
endmodule


//constant TIMESTEP integration, no differentiation used.  

module averager #(
	parameter NUM_BITS = 8,
	parameter SAMPLES = 8,
	parameter SAMPLE_BITS = `log2(SAMPLES);
	parameter SAMPLE_PERIOD = 10_000,
	parameter CLK_COUNTER_SIZE = 30
)(
	input clk,
	input [NUM_BITS-1:0] value,
	output [NUM_BITS-1:0] average
);
	reg [NUM_BITS-1 + SAMPLE_BITS : 0] sum = 0;
	reg [NUM_BITS-1:0] data [SAMPLES-1:0];
	reg [CLK_COUNTER_SIZE-1:0] clk_counter = 0;
	wire sample;

	assign average = sum >> SAMPLE_BITS;

	integer k;
	initial
		begin
		for (k = 0; k < SAMPLES - 1; k = k + 1) begin
		    data[k] = 0;
		end
	end

	assign sample = (clk_counter == SAMPLE_PERIOD);
	
	always @(posedge clk) begin
		clk_counter <= (clk_counter < SAMPLE_PERIOD) ? clk_counter + 1: 0;
	end

	always @(posedge sample) begin
		data[0] <= value;
		sum <= sum + value - data[SAMPLES-1];
	end

	genvar i;
	generate
	    for (i = 1; i < SAMPLES; i = i + 1) begin: test
	        always @(posedge sample) begin
	            data[i] <= data[i-1];
	        end
	    end
	endgenerate
endmodule


module differentiator #(
	parameter TIMESTEP = 10, //cycles
	parameter VALUE_MAX_SIZE = 10,
	parameter DERIVATIVE_MAX_SIZE = 20,
	parameter CLK_COUNTER_SIZE = 30
)
(
	input clk,
	input [VALUE_MAX_SIZE-1:0] value,
	output signed [DERIVATIVE_MAX_SIZE-1:0] derivative
);
	reg signed [DERIVATIVE_MAX_SIZE-1:0] d_dt = 0; 
	reg [VALUE_MAX_SIZE-1:0] prev_value = 0;
	reg [CLK_COUNTER_SIZE-1:0] clk_counter = 0;

	assign sample = (clk_counter == TIMESTEP);

	always @(posedge clk) begin
		clk_counter <= (clk_counter < TIMESTEP) ? clk_counter + 1: 0;
	end

	always @(posedge sample) begin
		d_dt <= value - prev_value;
		prev_value <= value;
	end
endmodule


module PI#(
	parameter NUM_BITS = 8,
	parameter SAMPLES = 8,
	parameter SAMPLE_BITS = `log2(SAMPLES),
	parameter SAMPLE_PERIOD = 10_000,
	parameter CLK_COUNTER_SIZE = 30,
	parameter Kp_Inv = 2,
	parameter KI_Inv = 2
)
(
	input clk,
	input [NUM_BITS-1:0] desired_value,
	input [NUM_BITS-1:0] read_value,
	input [NUM_BITS-1:0] current_output_value,
	output [NUM_BITS-1:0] output_value
)
	wire [NUM_BITS-1:0] average_error, error, control;
	assign error = desired_value - read_value;

	assign output_value = current_output_value + control
	// desired_value = read_value then output-value = current_output_value
	// desired_value > read_value, speed should increase, output_value = current_out_value + positive, so it increase
	// desired_value < read_value => error < 0 => outputvalue = current_out_value + negative
	//
	//

	assign control = error/Kp_Inv + average_error/KI_Inv;	

	averager #(
		.NUM_BITS(NUM_BITS),
		.SAMPLES(SAMPLES),
		.SAMPLE_BITS(SAMPLE_BITS),
		.SAMPLE_PERIOD(SAMPLE_PERIOD)
	) average1 (
		.clk(clk),
		.value(error),
		.average(average_error)
	);

endmodule


module Step_Controller#(
	parameter NUM_BITS = 8,
	parameter STEP_TIME = 500_000, //ClockCycles per increment
	parameter CLK_COUNTER_SIZE = `log2(STEP_TIME)
)(
	input clk,
	input [NUM_BITS-1] current_value,
	input [NUM_BITS-1] desired_value,
	input [NUM_BITS-1] read_value,
	output [NUM_BITS-1] output_value,
)
	wire [NUM_BITS-1:0] delta;
	reg [CLK_COUNTER_SIZE-1:0] clk_counter;
	reg [NUM_BITS-1:0] output_value_reg;

	assign delta = desired_value - read_value;
	assign output_value = output_value_reg;

	always@(posedge clk) begin
		clk_counter <= (clk_counter>STEP_TIME) ? 0 : clk_counter + 1;
		if (clk_counter == STEP_TIME && delta) output_value <= (delta > 0) ? current_value + 1 : current_value - 1;
		else output_value_reg <= output_value;
	end
endmodule



module Servo_Controller#(
	parameter NUM_BITS = 8,
	parameter PWM_PERIOD = 5,
	parameter DUTY_MAX = 255,
	parameter DUTY_MAX_BITS = `log2(DUTY_MAX)
	parameter STEP_TIME = 500_000

)(
	input clk,
	input [NUM_BITS-1] desired_value,
	input read_pwm,
	output output_pwm
)
	wire [NUM_BITS-1:0] read_value, controlled_value;
	reg [NUM_BITS-1:0] output_value_reg;

	always@(posedge clk) output_value_reg <= output_value;

	PWM_Gen #(
		.PWM_PERIOD(PWM_PERIOD),
		.DUTY_MAX(DUTY_MAX),
		.DUTY_MAX_BITS(DUTY_MAX_BITS)
	) gen(
		.clk(clk),
		.DUTY_NUM(output_value),
		.PWM(output_pwm)
	);

	PWM_Counter #(
		.PWM_PERIOD(PWM_COUNT_PERIOD),
		.DUTY_MAX(DUTY_MAX),
		.DUTY_MAX_BITS(DUTY_MAX_BITS)
	) count(
		.clk(clk),
		.pwm(read_pwm),
		.pwm_value(read_value)
	);

	Step_Controller #(
		.NUM_BITS(NUM_BITS),
		.STEP_TIME(STEP_TIME),
	) step(
		.clk(clk),
		.current_value(output_value_reg),
		.desired_value(desired_value),
		.read_value(read_value),
		.output_value(output_value),
	)
endmodule


module PID#(
	parameter VALUE_MAX_SIZE = 10,
	parameter MATH_MAX_SIZE = 20,
	parameter CLK_COUNTER_SIZE = 30,
	parameter TIMESTEP = 50_000,
	parameter INTEGRATION_TIME = 10,
	parameter INT_NORM = 1/INTEGRATION_TIME,
	parameter Kp = 1/2,
	parameter Ki = 1/4*INT_NORM,
	parameter Kd = 1/4
)
(
	input clk,
	input [VALUE_MAX_SIZE-1:0] error,
	output [VALUE_MAX_SIZE-1:0] control
);
	wire signed [MATH_MAX_SIZE-1:0] int, der, prop, preout, int_norm;

	assign prop = error;
	assign preout = Kp*prop + Ki*int + Kd*der;
	assign control = preout;

	integrator #(
		.TIMESTEP(TIMESTEP), //cycles
		.INTEGRATION_TIME(INTEGRATION_TIME), //integration_time in number of timesteps so i_t *  timestep = number of cycles in total integration
		.VALUE_MAX_SIZE(VALUE_MAX_SIZE),
		.INTEGRATION_MAX_SIZE(MATH_MAX_SIZE),
		.CLK_COUNTER_SIZE(CLK_COUNTER_SIZE)
	) integrate (
		.clk(clk),
		.value(error),
		.integration(int)
	);

	differentiator #(
		.TIMESTEP(TIMESTEP),
		.VALUE_MAX_SIZE(VALUE_MAX_SIZE),
		.DERIVATIVE_MAX_SIZE(MATH_MAX_SIZE),
		.CLK_COUNTER_SIZE(CLK_COUNTER_SIZE)
	) derivative (
		.clk(clk),
		.value(error),
		.derivative(der)
	);

endmodule